= gplug-modbus

image:https://github.com/gplug-ch/gplug-modbus/actions/workflows/makefile.yml/badge.svg[Build> Status]

A lightweight Modbus-TCP server implementation for <https://gplug.ch/[gPlug>] running on ESP32-C3 with Tasmota firmware, providing flexible user-configurable register mappings to serve SmartMeter and SunSpec protocol data efficiently.

== Table of Contents

. <<overview,Overview>>
. <<features,Features>>
. <<architecture-components,Architecture & Components>>
. <<prerequisites,Prerequisites>>
. <<installation,Installation>>
. <<usage-example,Usage / Example>>
. <<configuration,Configuration>>
. <<building-from-source,Building from Source>>
. <<limitations,Limitations>>
. <<license,License>>
. <<references,References>>

== Overview

This project implements a *lightweight Modbus-TCP server* in Berry Script (inside Tasmota) running on a gPlug device (ESP32-C3). It allows exposing SmartMeter or SunSpec data via Modbus, with flexible register mapping defined by the user.

Typical use case: you have a gPlug running Tasmota + Berry support, and want to read meter / inverter / device data from it via Modbus (for systems like SCADA, home automation, etc.).

== Features

* Implements Modbus TCP, *function code 3 (Read Holding Registers)*
* Runs entirely within Berry Script / Tasmota on the gPlug — no external hardware
* User-definable mapping (via `user-mapping.json`) to adapt to:
**Proprietary registers from your SmartMeter or device
** Standard SunSpec / device information models
* Lightweight, efficient, easily extendable

== Architecture & Components

The repository shows that the Berry application is organized into a set of script files:

* `main.be` — entry point to start and stop the Modbus service, which is configured to automatically start after a system reboot.
* `modbus.be` — handles Modbus request (json message), interacts with the smartmeter and composes the response.
* `obiscode.be` — handles OBIS codes (the standard codes for metered values), mapping them to internal data fields.
* `smartmeter.be` — logic for interacting with the SmartMeter, reading data via the local interface of gPlug.
* `serversocket.be` - network socket handling (server listening).
* `clientsocket.be` — network socket handling (client interactions).
* `logger.be` — logging and diagnostics.
* `middleware.be` - decodes and encodes the modbus messages to and from internal json messages.
* `handlers.be` — routing and processing of the decoded requests, generates a json response for the middleware.
* `constants.be` — definitions of fixed values, such as register offsets, scaling factors, etc.
* `sunspec.json` - containing model definitions for SunSpec compatibility.

== Prerequisites

* gPlug device running Tasmota (version ≥ 14.5.0) with Berry scripting enabled
* A SmartMeter (or inverter, sensor, etc.) from which you can read data (e.g. via MQTT / HTTP / sensor interfaces)
* Some familiarity with Modbus, register mapping, and JSON configuration

== Installation

. *Upload `.tapp` file*
+
Use Tasmota's web UI or other interfaces (HTTP, MQTT, etc.) to upload the compressed `.tapp` file.

. *Restart Berry VM*
+
After uploading, run `brrestart` from the Tasmota console to load the script.

. *Place mapping file*
+
Add your `user-mapping.json` (copied/modified from the template) into the correct directory so that the script can load it.

== Usage / Example

You can test using a Modbus client, e.g. <https://github.com/epsilonrt/mbpoll[`mbpoll`>].

[source,bash]
----

mbpoll -v -t 4 -1 -0 -p 502 -a 201 -r 40070 -c 59 gplugk.local
----

This reads 59 holding registers starting at address 40070 from unit ID 201 on port 502 of `gplugk.local`.
(Adapt the addresses, count, unit ID, etc. based on your mapping and environment.)

== Configuration

This JSON file defines which internal data values map to which Modbus registers (addresses, types, scaling, etc.).

You should base your mapping on either:

* Your device's proprietary registers / data points
* The *SunSpec Device Information Model*, if compatible

Include details like:

* Modbus *address* / offset
* Data *type* (e.g. unsigned, signed, float, etc.)
* *Scaling* or units
* *Description* / label

[NOTE]
====

If no user-specific mapping file is provided, the default link:./sunspec.json[`sunspec.json`] will be used
====

== Building from Source

If you want to build your own `.tapp`:

[source,bash]
----

make
----

This produces the deployable `.tapp` file you can upload onto your gPlug.

== Limitations

* Currently only supports *Modbus function code 3* (read holding registers)
* No automatic register discovery – user must configure mapping manually
* Error handling and diagnostics could be improved

== License

This project is licensed under *Apache-2.0*. You may use, modify, and distribute under the terms of that license.

== References

* <https://www.afs.enea.it/project/protosphera/Proto-Sphera_Full_Documents/mpdocs/docs_EEI/Modbus_Application_Protocol_V1_1b3.pdf[MODBUS> Application Protocol Specification V1.1b3 (for protocol reference)]
* <https://sunspec.org/wp-content/uploads/2025/01/SunSpec-Device-Information-Model-Specificiation-V1-2-1-1.pdf[SunSpec> Device Information Model Specification (for standard register mapping)]
* <https://berry-lang.github.io/[Berry> Scripting Language]
* <https://tasmota.github.io/docs/[Tasmota> documentation]
* <https://github.com/epsilonrt/mbpoll[mbpoll>] (for testing)
