= gplug-modbus

image:https://github.com/gplug-ch/gplug-modbus/actions/workflows/makefile.yml/badge.svg[Build Status]

A lightweight Modbus-TCP server implementation for https://gplug.ch/[gPlug] running on ESP32-C3 with Tasmota firmware, providing flexible user-configurable register mappings to serve SmartMeter and SunSpec protocol data efficiently.

== Table of Contents

<<overview,Overview>> +
<<features,Features>> +
<<architecture-components,Architecture & Components>> +
<<prerequisites,Prerequisites>> +
<<installation,Installation>> +
<<configuration,Configuration>> +
<<usage-example,Usage / Example>> +
<<testing,Testing>> +
<<building-from-source,Building from Source>> +
<<limitations,Limitations>> +
<<license,License>> +
<<references,References>> +

== Overview

This project implements a *lightweight Modbus-TCP server* in Berry Script (inside Tasmota) running on a gPlug device (ESP32-C3). It allows exposing SmartMeter or SunSpec data via Modbus, with flexible register mapping defined by the user.

Typical use case: you have a gPlug running Tasmota + Berry support, and want to read meter / inverter / device data from it via Modbus (for systems like SCADA, home automation, etc.).

== Features

* Implements Modbus TCP, *function code 3 (Read Holding Registers)*
* Runs entirely within Berry Script / Tasmota on the gPlug:: no external hardware
* User-definable mapping (via `user-mapping.json`) to adapt to:
** Proprietary registers from your SmartMeter device
** Standard SunSpec / device information models
* Lightweight, efficient, easily extendable

== Architecture & Components

The repository shows that the Berry application is organized into a set of script files:

`main.be`:: entry point to start and stop the Modbus service, which is configured to automatically start after a system reboot.
`modbus.be`:: handles Modbus request (json message), interacts with the smartmeter and composes the response.
`obiscode.be`:: handles OBIS codes (the standard codes for metered values), mapping them to internal data fields.
`smartmeter.be`:: logic for interacting with the SmartMeter, reading data via the local interface of gPlug.
`serversocket.be`:: network socket handling (server listening).
`clientsocket.be`:: network socket handling (client interactions).
`logger.be`:: logging and diagnostics.
`middleware.be`:: decodes and encodes the modbus messages to and from internal json messages.
`handlers.be`:: routing and processing of the decoded requests, generates a json response for the middleware.
`constants.be`:: definitions of fixed values, such as register offsets, scaling factors, etc.
`sunspec.json`:: containing model definitions for SunSpec compatibility.

== Prerequisites

- gPlug device running Tasmota (version ≥ 14.5.0) with Berry scripting enabled +
- A SmartMeter (or inverter, sensor, etc.) from which you can read data (e.g. via MQTT / HTTP / sensor interfaces) +
- Some familiarity with Modbus, register mapping, and JSON configuration +

== Installation

. *Upload `.tapp` file* +
Use Tasmota's web UI or other interfaces (HTTP, MQTT, etc.) to upload the compressed `.tapp` file.

. *Restart Berry VM* +
After uploading, run `brrestart` from the Tasmota console to load the script.

. *Place mapping file* (Optional) +
Add your `user-mapping.json` (copied/modified from the template) into the correct directory so that the script can load it.

== Configuration

the JSON file link:./sunspec.json[`sunspec.json`] - or your file `user-mapping.json` - defines which internal data values map to which Modbus registers (addresses, types, scaling, etc.).

You should base your mapping on either:

* Your device's proprietary registers / data points
* The *SunSpec Device Information Model*, if compatible

Include details like:

* Modbus *address* / offset
* Data *type* (e.g. unsigned, signed, float, etc.)
* *Scaling* or units
* *Description* / label

*NOTE:* If no user-specific mapping file is provided, the internal file link:./sunspec.json[`sunspec.json`] will be used

== Usage / Example

You can interact with the Modbus-TCP server using a Modbus client, e.g. https://github.com/epsilonrt/mbpoll[`mbpoll`].

[source,bash]
----
mbpoll -v -t 4 -1 -0 -p 502 -a 201 -r 40070 -c 59 gplugk.local
----

This reads 59 holding registers starting at address 40070 from unit ID 201 on port 502 of `gplugk.local`.
(Adapt the addresses, count, unit ID, etc. based on your mapping and environment.)

== Testing

=== Unit Tests

==== Prerequisites

https://berry.readthedocs.io/en/latest/source/en/Chapter-1.html#get-interpreter[Berry VM] must be installed and configured on your local machine .

==== Running the Tests
You can run unit tests for individual components by executing the `test.be` script in the Berry environment. This script includes test cases for functions in `handler.be`, `middleware.be` and `modbus.be`. 

[source,bash]
----
make test
----

*Note*: File `tests/tasmota.be` contains mock implementations of Tasmota functions used in the tests.

=== Integration Tests

==== Prerequisites

https://github.com/epsilonrt/mbpoll[mbpoll] must be installed on your local machine.

==== Running the Tests
For end-to-end testing, you can use a Modbus client like `mbpoll` to send requests to the gPlug and verify the responses. Use the python script `load_test.py` to simulate multiple concurrent Modbus requests and check for correct behavior under load.

Verify that python is installed, then run:

[source,bash]
----
cd tools/load_test
python load_test.py -h
usage: load_test.py [-h] [--host HOST] [--port PORT] [--slave-id SLAVE_ID] [--register REGISTER]
                    [--count COUNT] [--threads THREADS] [--tests-per-thread TESTS_PER_THREAD]
                    [--sequential-tests SEQUENTIAL_TESTS] [--delay DELAY] [--output OUTPUT]
                    [--quiet]

Load test mbpoll Modbus command

options:
  -h, --help            show this help message and exit
  --host HOST           Target host (default: gplugk.local)
  --port PORT           Port number (default: 502)
  --slave-id SLAVE_ID   Slave ID (default: 201)
  --register REGISTER   Register address (default: 40070)
  --count COUNT         Number of registers (default: 59)
  --threads THREADS     Number of concurrent threads (default: 1)
  --tests-per-thread TESTS_PER_THREAD
                        Tests per thread (default: 1)
  --sequential-tests SEQUENTIAL_TESTS
                        Run N tests sequentially instead of concurrent
  --delay DELAY         Delay between tests in seconds (default: 0)
  --output OUTPUT       Save detailed results to JSON file
  --quiet               Disable verbose output from mbpoll
----

== Building from Source

If you want to build your own `.tapp` just type:

[source,bash]
----
make
----

This produces in your `build` directory the deployable `.tapp` file you can upload onto your gPlug.

== Limitations

* Currently only supports *Modbus function code 3* (read holding registers)
* No automatic register discovery – the user must either configure the mapping manually or rely on the default `sunspec.json`
* Error handling and diagnostics could be improved

== Contributing

Contributions are welcome! Please see link:CONTRIBUTING.adoc[CONTRIBUTING.adoc] for guidelines on how to contribute to this project.

== License

This project is licensed under *Apache-2.0*. You may use, modify, and distribute under the terms of that license.

== References

* https://www.afs.enea.it/project/protosphera/Proto-Sphera_Full_Documents/mpdocs/docs_EEI/Modbus_Application_Protocol_V1_1b3.pdf[MODBUS Application Protocol Specification V1.1b3 (for protocol reference)]
* https://sunspec.org/wp-content/uploads/2025/01/SunSpec-Device-Information-Model-Specificiation-V1-2-1-1.pdf[SunSpec Device Information Model Specification (for standard register mapping)]
* https://berry-lang.github.io/[Berry Scripting Language]
* https://tasmota.github.io/docs/[Tasmota documentation]
* https://github.com/epsilonrt/mbpoll[mbpoll] (for testing)
* link:CLAUDE.md[CLAUDE.md] (AI-assisted development context)
